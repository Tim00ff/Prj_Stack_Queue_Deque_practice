#include <iostream>  // Подключаем стандартную библиотеку для ввода/вывода
#include <string>  // Подключаем стандартную библиотеку для работы со строками
#include <stack>  // Подключаем стандартную библиотеку для работы со стеком
#include <queue>  // Подключаем стандартную библиотеку для работы с очередью
#include <deque>  // Подключаем стандартную библиотеку для работы с деком

using namespace std;  // Используем пространство имен std для упрощения доступа к стандартным классам и функциям

string removeConsecutiveDuplicatesUsingStack(const string& input) {  // Объявляем функцию для удаления последовательных дубликатов с использованием стека
    stack<char> charStack;  // Создаем стек для хранения уникальных символов
    for (char current : input) {  // Проходим по каждому символу входной строки
        if (charStack.empty() || current != charStack.top()) {  // Если стек пустой или текущий символ отличается от верхнего элемента стека
            charStack.push(current);  // Помещаем текущий символ на вершину стека
        }
    }
    string result;  // Создаем строку для хранения результата
    while (!charStack.empty()) {  // Пока стек не пустой
        result = charStack.top() + result;  // Добавляем верхний символ стека в начало результирующей строки
        charStack.pop();  // Удаляем верхний элемент из стека
    }
    return result;  // Возвращаем строку без последовательных дубликатов
}

string removeConsecutiveDuplicatesUsingQueue(const string& input) {  // Объявляем функцию для удаления последовательных дубликатов с использованием очереди
    queue<char> charQueue;  // Создаем очередь для хранения уникальных символов
    for (char current : input) {  // Проходим по каждому символу входной строки
        if (charQueue.empty() || current != charQueue.back()) {  // Если очередь пустая или текущий символ отличается от последнего элемента очереди
            charQueue.push(current);  // Помещаем текущий символ в конец очереди
        }
    }
    string result;  // Создаем строку для хранения результата
    while (!charQueue.empty()) {  // Пока очередь не пустая
        result += charQueue.front();  // Добавляем первый символ очереди к результирующей строке
        charQueue.pop();  // Удаляем первый элемент из очереди
    }
    return result;  // Возвращаем строку без последовательных дубликатов
}

string removeConsecutiveDuplicatesUsingDeque(const string& input) {  // Объявляем функцию для удаления последовательных дубликатов с использованием дека
    deque<char> charDeque;  // Создаем дек для хранения уникальных символов
    for (char current : input) {  // Проходим по каждому символу входной строки
        if (charDeque.empty() || current != charDeque.back()) {  // Если дек пустой или текущий символ отличается от последнего элемента дека
            charDeque.push_back(current);  // Помещаем текущий символ в конец дека
        }
    }
    string result;  // Создаем строку для хранения результата
    while (!charDeque.empty()) {  // Пока дек не пустой
        result += charDeque.front();  // Добавляем первый символ дека к результирующей строке
        charDeque.pop_front();  // Удаляем первый элемент из дека
    }
    return result;  // Возвращаем строку без последовательных дубликатов
}

int main() {
    string input = "1122334455";  // Входная строка, содержащая последовательные дубликаты
    int choice;  // Переменная для хранения выбора алгоритма
    cout << "Выберите алгоритм (1 - стек, 2 - очередь, 3 - дек): ";
    cin >> choice;  // Ввод выбора алгоритма
    string result;  // Переменная для хранения результата
    switch (choice) {  // Выбор алгоритма в зависимости от введенного числа
        case 1:
            result = removeConsecutiveDuplicatesUsingStack(input);  // Вызываем функцию для удаления дубликатов с использованием стека
            break;
        case 2:
            result = removeConsecutiveDuplicatesUsingQueue(input);  // Вызываем функцию для удаления дубликатов с использованием очереди
            break;
        case 3:
            result = removeConsecutiveDuplicatesUsingDeque(input);  // Вызываем функцию для удаления дубликатов с использованием дека
            break;
        default:
            cout << "Неверный выбор алгоритма!" << endl;  // Выводим сообщение об ошибке, если выбран неверный алгоритм
    }
    cout << "Результат: " << result << endl;  // Выводим результат
    return 0;  // Возвращаем 0, чтобы указать успешное завершение программы
}